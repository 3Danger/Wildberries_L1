# Устные вопросы

1. Какой самый эффективный способ конкатенации строк?\
```
Ответ: strings.Builder{}
```
2. Что такое интерфейсы, как они применяются в Go?\
```
Ответ:
Интерфейс — это набор методов, представляющих стандартное поведение для различных типов данных.

Это позволяет нам вместо фактических реализаций, опираться на более высокие абстракции (интерфейсы), 
позволяя методам работать с различными объектами, реализующими один и тот же интерфейс.
```
3. Чем отличаются RWMutex от Mutex?\
```
Ответ:
У RWMutex есть дополнительно RLock и RUnlock которые используются при чтениии.
При выполнении Rlock() блокируется Lock(), но Rlock() не блокируется при этом, 
если заблокировать Lock() то блокируется и Rlock(). Сам Rlock() не блокируется для себя.
Это дает возможность параллельно читать повышая производительность.
``` 
4. Чем отличаются буферизированные и не буферизированные каналы?\
``` 
Ответ:
По умолчанию размер буффера равет нулю, в этом случае запись блокируется пока не появится читающий,
Если задать буфер больше нуля, то запись не блокируется пока не заполнится буфер, по заполнении буфера -
запись блокируется пока не появится читающий и не освободит место в буфере для записи.
```  
5. Какой размер у структуры struct{}{}?\
``` 
Ответ: struct{}{} == 0
```  
6. Есть ли в Go перегрузка методов или операторов?\
``` 
Ответ: Перегрузки нету, го так и был задуман, чтоб код писался и читался максимально понятно и легко.
```  
7. В какой последовательности будут выведены элементы map[int]int?\
```
Пример:
m[0]=1
m[1]=124
m[2]=281

Ответ:
Если выводить через fmt.Print то порядок будет по значению ключа, по возрастанию.
Если выводить через цикл for _, _ := range{} то порядок будет всегда рандомный. 
```

8. В чем разница make и new\
``` 
Ответ:
make - инициализирует объект
new - аллоцирует память в куче, но не инициализирует
``` 


9. Сколько существует способов задать переменную типа slice или map?\
``` 
Ответ:
В основном 3 способа, make, new и литералы.
``` 


10. Что выведет данная программа и почему?
```
func update(p *int) {
    b := 2
    p = &b
}

func main() {
    var (a = 1
        p = &a)
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
Ответ: 1, 1
Потому что в начале \*p указывает на \а значение которой 1,
update() изменяет только копию ссылки, 
поэтому в main(){} указатель *p не изменил свой первоначальный адресс 
``` 
11. Что выведет данная программа и почему?

```
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
Ответ:
Выведет числа 0...4, возможно не по порядку, и далее дедлок, 
посколько мы передаем WG по значению а не по ссылке. 
```
12. Что выведет данная программа и почему?

```
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
Ответ: 0
Выведет 0, потому что переменная N которая в теле if{} объявлена заново,
и это уже другая, новая N в пределах тела if{} который перекрывает старую N.
Старая N остается неизменной.
```

13. Что выведет данная программа и почему?

```
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
Ответ: [100, 2, 3, 4, 5]
Потому что передав слайс в someAction() мы передали новый слайс в котором хранится тот же самый указатель,
который мы можем изменить, где и было записано 100 в нулевой индекс.
Далее там есть вызов append который реаллоцирует память,
и теперь все изменения в ней, не затронут оригинальный слайс. поэтому мы не увидели в слайсе в конце 6 
```

14. Что выведет данная программа и почему?

```
func main() {
    slice := []string{"a", "a"}

    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
Ответ:
[b, b, a]
[a, a]

Потому что слайсл в main имеет [a, a]
Далее в анонимной функции мы этот, именно этот слайс, никак не меняем, 
потому что в анонимной функции мы заново реалоцировали слайс и напечатали его, [b, b, a] 
затем выйдя из анонимной функции, мы напечатали старый слайс из main(){} [a, a]
```
