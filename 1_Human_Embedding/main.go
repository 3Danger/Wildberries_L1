package main

import (
	"fmt"
	"reflect"
)

/*
 <-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->
 <-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-- 1. Встраивание -->->->->->->->->->->->->->->->->->->->->->
 <-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->
*/

type Human struct {
	name string
}

func (h Human) SayHello() {
	fmt.Println(h.name + ": stays hello world")
}
func (h *Human) SetName(name string) { h.name = name }

/*
	В следующей структуре Action происходит встраивание структуры Human
	это можно представить как структуру в структуре, но с некоторыми отличиями,
	о которых приведем пример далее
*/
type Action struct {
	Human
	someField string
}

func example1() {
	fmt.Println("\n1. Встраивание:")
	// Создадим объект Action
	ac := Action{}
	// Установить значения для полей можно так:
	ac = Action{Human{"Biba"}, "someValue"}                   // way 1
	ac = Action{Human: Human{"Biba"}, someField: "someValue"} // way 2

	// У объекта Action можно неявно вызвать метод принадлежащий Human SayHello()
	ac.SayHello()
	// Так же можно явно вызвать этот метод
	ac.Human.SayHello()
	// Последнее может быть полезна в случае коллизии между встраиваемых структур.
	// При вызове метода, сначала он ищется у вызывающего типа,
	// — после этого у встроенных, то же самое справедливо для Полей.
}

//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->
//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-- 2. Переопределение -->->->->->->->->->->->->->->->->->->->->
//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->

type Sayer2 interface {
	SayHello()
}
type Human2 struct {
	name string
}

// Action2 может переопределить метод.
// Причем метод перекрывается по имени, без учета полной сигнатуры метода.
type Action2 struct {
	Human2
}

func (h Human2) SayHello() {
	fmt.Printf("%s: says Hello World! \n", h.name)
}

func (h Action2) SayHello(g string) {
	fmt.Printf("%s: says Hello %s\n", g, h.name)
}

func Say(s Sayer2) {
	s.SayHello()
}

func example2() {
	fmt.Println("\n2. Переопределение:")
	h := Human2{"Boba1"}
	a := Action2{Human2{"Boba2"}}

	h.SayHello()        // <- работает
	Say(h)              // <- работает
	a.Human2.SayHello() // <- работает
	// a.SayHello()        // <- Недостаточно аргументов a.SayHello() потому что метод переопределен, и хоть и сигнатура отличается!
	// Say(a)              // <- не может принимать `a` (тип Action2) в качестве типа Sayer2 в качестве аргумента,
	// ближайшее переопределение в иерархии `наследования` уже не соответствует интерфейсу Sayer2.
}

//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->
//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-- 3. Анонимные структуры -->->->->->->->->->->->->->->->->->->->
//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->

func example3() {
	fmt.Println("\n3. Анонимные структуры:")
	// Как известно у анонимных структур нельзя объявить методы.
	// Но благодаря встраиванию их можно добавить:
	anon := struct {
		Human
		someField string
	}{
		Human{"Tom"},
		"Jerry",
	}
	anon.SayHello()
	anon.Human.SayHello()
}

//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->
//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<- 4. Встраивания указателя ->->->->->->->->->->->->->->->->->->->
//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->

type Action4 struct {
	*Human
	someField string
}

func example4() {
	fmt.Println("\n4. Встраивания указателя:")
	/*
		Указатель позволяет использовать один экземпляр типа
		в нескольких других экземплярах типа в которые он встроен.
		Другими словами, часть данных будет общей для всех экземпляров.
		В некоторых случаях это может помочь с экономией памяти.
	*/
	GarryHuman := &Human{"Garry"}
	a1 := Action4{GarryHuman, "someValue"}
	a2 := Action4{GarryHuman, "someValue"}
	a3 := Action4{GarryHuman, "someValue"}
	a4 := Action4{GarryHuman, "someValue"}

	GarryHuman.SetName("NotGarry")
	for _, a := range []Action4{a1, a2, a3, a4} {
		a.SayHello()
	}
	// Важно помнить, что при неявной инициализации,
	// указатель имеет значение nil,
	// соответственно при его использовании будет panic:

	// a := Action3{}
	// a.StayHello() <------ тут возникнет паника, при попытке разыменовать nil у указателя Human
}

//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->
//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<- 5. Встраивание интерфейса -->->->->->->->->->->->->->->->->->->
//<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-->->->->->->->->->->->->->->->->->->->->->->->->->

//	Вы можете использовать это, чтобы явно указать,
//	что тип встраивания должен удовлетворять встроенному интерфейсу
//	и в то же время скрывать его данные.
//	В данном примере можно сделать это следующим образом:

type SayerHello interface {
	SayHello()
}

type Action5 struct {
	SayerHello
}

func CallerHello(s SayerHello) {
	s.SayHello()
}

func example5() {
	fmt.Println("\n5. Встраивание интерфейса:")

	a := Action5{Human{"George Bush"}}
	a.SayHello()
	a.SayerHello.SayHello()
	// Оно так же будет соответствовать
	// тому интерфейсу который мы встроили в неё
	CallerHello(a)
	CallerHello(a.SayerHello)
	// Для доступа к полям и свойствам Human которых нет в интерфейсе -
	//- так же можно вытянуть исходный тип Human из данного интерфейса:
	if reflect.TypeOf(a.SayerHello) == reflect.TypeOf(Human{}) {
		h := a.SayerHello.(Human)
		h.SayHello()
	}
}

func main() {
	example1()
	example2()
	example3()
	example4()
	example5()
}
